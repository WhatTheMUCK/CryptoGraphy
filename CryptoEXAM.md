# 1. Односторонние функции

Односторонняя функция — это функция *f*, которая удовлетворяет следующим условиям:

1. **Легкость вычисления**: Для любого входного значения *x* вычисление *f(x)* относительно быстрое и эффективное.
2. **Трудность обратного вычисления**: Для практически всех выходных значений *y* из множества значений *f(x)* вычисление обратного значения *x* (то есть нахождение такого *x*, что *f(x) = y*) чрезвычайно трудное.

## Примеры односторонних функций

1. **Функция возведения в степень в конечных полях**: Пусть *p* — простое число, тогда функция *f(x) = g<sup>x</sup> mod p*, где *g* — примитивный корень по модулю *p*, является односторонней. Вычислить *g<sup>x</sup> mod p* легко, но найти *x* по известным *g* и *g<sup>x</sup> mod p* (проблема дискретного логарифма) крайне сложно.

2. **Функция умножения**: Пусть *p* и *q* — два больших простых числа. Функция *f(x, y) = xy* является односторонней. Легко перемножить два числа, но факторизация произведения *n = pq* на множители *p* и *q* является трудной задачей.

## Использование односторонних функций

1. **Хеш-функции**: Односторонние функции используются для построения криптографических хеш-функций. Хорошая криптографическая хеш-функция должна быть односторонней и устойчивой к коллизиям (случайным совпадениям хешей для различных входных данных).

2. **Электронная подпись**: В схемах цифровой подписи также используются односторонние функции. Примером может служить схема подписи RSA, где функция *f(x) = x<sup>e</sup> mod n* является односторонней.

3. **Шифрование**: Односторонние функции используются в асимметричных шифровальных алгоритмах. Например, в алгоритме RSA шифрование *c = m<sup>e</sup> mod n* является односторонней функцией.

## Свойства односторонних функций

1. **Сопротивляемость предсказаниям**: Трудно предсказать выходное значение функции для случайного входа без вычисления самой функции.
2. **Устойчивость к атаке на основе известного текста**: Если известно значение функции для нескольких входных данных, это не помогает в нахождении функции для новых входов.
3. **Устойчивость к коллизиям**: Сложно найти два различных входных значения, которые дают один и тот же выход.

## Важные замечания

- Односторонние функции могут не существовать в строгом математическом смысле (то есть может не существовать доказательства их существования), но в практической криптографии используются функции, которые считаются односторонними на основе текущих знаний и отсутствия известных эффективных атак на них.
- Примером может служить использование факторизации целых чисел и проблема дискретного логарифма в качестве основ для односторонних функций.

## Проблема дискретного логарифма

Проблема дискретного логарифма является одной из фундаментальных задач в области криптографии и тесно связана с безопасностью многих криптографических систем, таких как Диффи-Хеллман (Diffie-Hellman), DSA (Digital Signature Algorithm) и ElGamal.

### Определение

Пусть *G* — циклическая группа с порядком *n* и генератором *g*. Для любого элемента *h* из *G*, дискретным логарифмом *h* по основанию *g* называется такое целое число *x*, что выполняется равенство:

* g<sup>x</sup> ≡ h mod p

где *p* — порядок группы *G*.

### Формальная постановка задачи

Дана группа *G*, генератор *g* и элемент *h* из *G*, найти целое число *x* такое, что:

* g<sup>x</sup> ≡ h mod p

## Свойства и сложности

1. **Односторонняя функция**: Проблема дискретного логарифма считается сложной задачей, то есть вычисление *g<sup>x</sup> mod p* для известного *x* относительно просто, но нахождение *x* для известного *g* и *h* (то есть обратная задача) является вычислительно сложной.
2. **Безопасность криптографических систем**: Многие криптографические системы основываются на предположении, что задача дискретного логарифма является вычислительно сложной и не имеет эффективных алгоритмов для ее решения в общем случае.

### Применение в криптографии

1. **Протокол Диффи-Хеллмана**: Протокол ключевого обмена, основанный на проблеме дискретного логарифма. Стороны обмениваются значениями, вычисленными как *g<sup>a</sup> mod p* и *g<sup>b</sup> mod p*, где *a* и *b* — их секретные ключи. Совместный секретный ключ вычисляется как *(g<sup>b</sup>)<sup>a</sup> mod p* или *(g<sup>a</sup>)<sup>b</sup> mod p*, что эквивалентно *g<sup>ab</sup> mod p*.
2. **Электронные подписи (DSA)**: Использует сложность дискретного логарифма для создания цифровых подписей, которые могут быть проверены, но не могут быть подделаны без знания секретного ключа.
3. **Шифрование (ElGamal)**: Схема шифрования, основанная на проблеме дискретного логарифма. Использует пары ключей (открытый и закрытый) для шифрования и расшифрования сообщений.

### Алгоритмы решения

Хотя в общем случае проблема дискретного логарифма является сложной, существуют несколько известных алгоритмов для ее решения:

1. **Метод грубой силы (Brute force)**: Перебор всех возможных значений *x* до тех пор, пока не найдется такое, что *g<sup>x</sup> ≡ h mod p*. Этот метод крайне неэффективен для больших значений *p*.
2. **Алгоритм "Шаг младенца, шаг великана" (Baby-step giant-step)**: Разделяет задачу на два меньших подзадачи, существенно сокращая время решения до *O(√n)*.
3. **Метод Полларда "ро" (Pollard's rho)**: Применяет случайные блуждания для нахождения дискретного логарифма, также работает в среднем за *O(√n)*.
4. **Алгоритмы на эллиптических кривых**: Используют специфические свойства эллиптических кривых для решения дискретного логарифма на них.

---

# 2. Хеш-функции

Хеш-функции играют важную роль в криптографии и других областях информатики. Они используются для преобразования входных данных произвольной длины в фиксированное значение, которое представляет собой "отпечаток" данных.

## Определение

Хеш-функция *H* — это функция, которая принимает входные данные произвольной длины и преобразует их в выходное значение фиксированной длины, называемое хешем или дайджестом. 

## Свойства хеш-функций

1. **Определенность**: Для любого заданного входа *x*, хеш-функция всегда возвращает одно и то же значение *H(x)*.
2. **Эффективность**: Вычисление хеш-значения *H(x)* для любого входа *x* должно быть быстрым.
3. **Предварительное изображение**: Должно быть трудно найти два различных входа *x* и *y* такие, что *H(x) = H(y)*. Это свойство известно как устойчивость к коллизиям.
4. **Односторонность**: Для заданного хеша *y* должно быть вычислительно трудно найти любой вход *x* такой, что *H(x) = y*.
5. **Сопротивляемость к коллизиям**: Должно быть трудно найти любые два различных входа *x* и *y* такие, что *H(x) = H(y)*.

## Примеры хеш-функций

1. **MD5**: Ранее широко использовалась, но теперь считается небезопасной из-за уязвимостей к коллизиям.
2. **SHA-1**: Также устарела и не рекомендуется к использованию из-за уязвимостей к коллизиям.
3. **SHA-256**: Часть семейства SHA-2, считается безопасной и широко используется.

## Применение хеш-функций

1. **Проверка целостности данных**: Хеш-функции используются для создания контрольных сумм файлов и сообщений, чтобы проверить их целостность при передаче или хранении.
2. **Цифровые подписи**: В схемах цифровых подписей хеш-функции используются для создания дайджестов сообщений, которые затем подписываются с помощью закрытого ключа.
3. **Хранение паролей**: Пароли пользователей часто хешируются перед хранением в базе данных для повышения безопасности.
4. **Криптографические протоколы**: Хеш-функции используются в различных криптографических протоколах, таких как HMAC (Хеш-Message Authentication Code), для обеспечения аутентификации и целостности данных.

## Примеры использования хеш-функций

1. **Контрольные суммы и проверка целостности**: Например, при передаче файла можно вычислить его хеш на стороне отправителя и сравнить с хешем, вычисленным на стороне получателя. Если хеши совпадают, значит файл не был изменен.
2. **Хранение паролей**: Пароли пользователей хешируются перед хранением в базе данных. При проверке пароля пользователь вводит свой пароль, который снова хешируется, и сравнивается с хешем, хранящимся в базе данных.
3. **Цифровые подписи**: При создании цифровой подписи сообщение сначала хешируется, затем хеш шифруется закрытым ключом отправителя. Получатель может расшифровать подпись с помощью открытого ключа отправителя и сравнить полученный хеш с хешем сообщения, чтобы удостовериться в подлинности и целостности сообщения.

---

# 3. Гипотеза P != NP

Гипотеза P ≠ NP является одной из самых фундаментальных и обсуждаемых проблем в теоретической информатике и математике. Она связана с вопросом о том, насколько сложно решать определенные классы задач.

## Определение

**Класс P** (полиномиальные проблемы) включает в себя все задачи, которые могут быть решены детерминированным алгоритмом за полиномиальное время, то есть время выполнения алгоритма ограничено многочленом от размера входных данных.

**Класс NP** (недетерминированные полиномиальные проблемы) включает в себя все задачи, для которых можно проверить правильность решения за полиномиальное время.

Гипотеза P ≠ NP утверждает, что не все задачи из класса NP могут быть решены за полиномиальное время, то есть P не равно NP.

## Значимость гипотезы

1. **Криптография**: Множество криптографических алгоритмов основано на предположении, что некоторые задачи трудно решить за полиномиальное время. Если P = NP, многие криптографические системы станут уязвимыми.
2. **Алгоритмы и вычислительная сложность**: Подтверждение или опровержение гипотезы поможет лучше понять, какие задачи могут быть эффективно решены и какие задачи требуют экспоненциального времени.

## Примеры задач из NP

1. **Задача о коммивояжере**: Найти кратчайший путь, который проходит через заданный список городов и возвращается в исходный город.
2. **Задача о рюкзаке**: Определить, какие предметы с заданной стоимостью и весом следует включить в рюкзак, чтобы максимизировать общую стоимость при ограничении на общий вес.

## Текущий статус

Гипотеза P ≠ NP остается недоказанной, и это одна из самых известных нерешенных проблем в информатике. Решение этой проблемы является одним из семи "Проблем тысячелетия", для которых Clay Mathematics Institute предложил приз в размере 1 миллион долларов за доказательство.

---

# 4. Симметричное шифрование

Симметричное шифрование — это метод шифрования, в котором для шифрования и расшифрования данных используется один и тот же ключ. Этот метод является одним из самых старых и наиболее широко используемых способов обеспечения конфиденциальности данных.

## Основные характеристики

1. **Один ключ для шифрования и расшифрования**: Симметричное шифрование использует один и тот же ключ как для шифрования, так и для расшифрования данных.
2. **Быстрота**: Алгоритмы симметричного шифрования, как правило, быстрее асимметричных алгоритмов, что делает их предпочтительными для шифрования больших объемов данных.
3. **Требование безопасной передачи ключа**: Поскольку один и тот же ключ используется и для шифрования, и для расшифрования, ключ должен быть передан между сторонами по защищенному каналу.

## Примеры алгоритмов симметричного шифрования

1. **AES (Advanced Encryption Standard)**: Один из самых широко используемых алгоритмов симметричного шифрования. Он поддерживает ключи длиной 128, 192 и 256 бит и обеспечивает высокий уровень безопасности.
2. **DES (Data Encryption Standard)**: Ранее широко использовался, но теперь считается устаревшим из-за относительно небольшой длины ключа (56 бит) и уязвимостей к атакам.
3. **Triple DES (3DES)**: Улучшенная версия DES, которая шифрует данные три раза с использованием двух или трех различных ключей для повышения безопасности.
4. **RC4**: Потоковый шифр, ранее широко использовавшийся в таких протоколах, как SSL/TLS, но в настоящее время считается небезопасным из-за выявленных уязвимостей.

## Применение симметричного шифрования

1. **Защита данных**: Используется для защиты конфиденциальных данных при передаче и хранении.
2. **VPN (Virtual Private Network)**: Используется для шифрования трафика между пользователем и сетью, обеспечивая защиту данных при передаче через незащищенные сети.
3. **Шифрование файлов и дисков**: Используется для шифрования содержимого файлов и целых дисков, чтобы предотвратить несанкционированный доступ.

## Преимущества

1. **Высокая скорость шифрования и расшифрования**: Подходит для шифрования больших объемов данных.
2. **Простота реализации**: Алгоритмы симметричного шифрования обычно проще в реализации по сравнению с асимметричными.

## Недостатки

1. **Проблема управления ключами**: Необходимость безопасной передачи и хранения ключей представляет собой значительную проблему.
2. **Отсутствие механизма аутентификации**: Симметричное шифрование не предоставляет встроенного механизма для проверки подлинности отправителя или получателя.

---

# 5. Асимметричное шифрование

Асимметричное шифрование, также известное как шифрование с открытым ключом, использует пару ключей: открытый ключ для шифрования и закрытый ключ для расшифрования. Это позволяет решить проблему безопасного обмена ключами, присущую симметричному шифрованию.

## Основные характеристики

1. **Два ключа**: Открытый ключ используется для шифрования данных, а закрытый ключ — для их расшифрования. Открытый ключ может быть свободно распространен, в то время как закрытый ключ должен храниться в секрете.
2. **Безопасный обмен ключами**: Асимметричное шифрование решает проблему передачи ключей, так как открытый ключ можно распространять без риска компрометации безопасности.
3. **Медленнее симметричного шифрования**: Алгоритмы асимметричного шифрования обычно медленнее, поэтому их часто используют для шифрования небольших объемов данных, таких как ключи для симметричного шифрования.

## Примеры алгоритмов асимметричного шифрования

1. **RSA (Rivest-Shamir-Adleman)**: Один из самых широко используемых алгоритмов асимметричного шифрования. Он основан на сложности факторизации больших чисел.
2. **DSA (Digital Signature Algorithm)**: Алгоритм, используемый для цифровых подписей и основанный на математических свойствах дискретных логарифмов.
3. **ECC (Elliptic Curve Cryptography)**: Использует математические свойства эллиптических кривых и обеспечивает высокий уровень безопасности при меньшей длине ключа по сравнению с RSA.

## Применение асимметричного шифрования

1. **Цифровые подписи**: Обеспечивают аутентификацию и целостность данных. Отправитель подписывает сообщение своим закрытым ключом, а получатель проверяет подпись с помощью открытого ключа отправителя.
2. **Обмен ключами**: Используется для безопасного обмена ключами симметричного шифрования, которые затем используются для шифрования данных.
3. **SSL/TLS**: Протоколы, обеспечивающие защищенные соединения в интернете. Асимметричное шифрование используется для аутентификации и обмена ключами симметричного шифрования.

## Преимущества

1. **Безопасный обмен ключами**: Решает проблему передачи ключей, присущую симметричному шифрованию.
2. **Аутентификация и цифровые подписи**: Обеспечивает механизм для аутентификации отправителя и проверки целостности данных.

## Недостатки

1. **Медленнее симметричного шифрования**: Не подходит для шифрования больших объемов данных.
2. **Сложность реализации**: Алгоритмы асимметричного шифрования сложнее в реализации и требуют больше вычислительных ресурсов.

---

# 6. Доказательства с нулевым разглашением

Доказательства с нулевым разглашением (Zero-Knowledge Proofs) — это криптографический метод, который позволяет одной стороне (доказывающему) убедить другую сторону (проверяющего) в том, что утверждение истинно, без разглашения какой-либо дополнительной информации, кроме факта истинности утверждения.

## Основные характеристики

1. **Полнота (Completeness)**: Если утверждение истинно, то честный проверяющий будет убежден в этом доказательством, представленным честным доказывающим.
2. **Корректность (Soundness)**: Если утверждение ложно, то ни один мошеннический доказывающий не сможет убедить честного проверяющего в его истинности, кроме как с ничтожно малой вероятностью.
3. **Нулевое разглашение (Zero-Knowledge)**: Если утверждение истинно, проверяющий не узнает никакой дополнительной информации, кроме факта истинности утверждения. Это означает, что проверяющий не может использовать доказательство для получения дополнительных данных.

## Примеры доказательств с нулевым разглашением

1. **Протоколы интерактивных доказательств**: В таких протоколах доказывающий и проверяющий обмениваются сообщениями. Примером является протокол Фиата-Шамира.
2. **Неинтерактивные доказательства с нулевым разглашением (NIZK)**: В таких протоколах доказывающий может создать доказательство, которое может быть проверено любым проверяющим без дальнейшего взаимодействия. Примером является использование гомоморфного шифрования и zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge).

## Применение доказательств с нулевым разглашением

1. **Аутентификация**: Позволяют одной стороне доказать другой, что она знает определенную информацию (например, пароль), не раскрывая саму информацию.
2. **Криптовалюты**: В криптовалютах, таких как Zcash, используются zk-SNARKs для обеспечения приватности транзакций.
3. **Электронное голосование**: Обеспечивают проверку правильности голосования без раскрытия выбора каждого избирателя.

## Преимущества

1. **Повышение безопасности**: Проверяющий не получает дополнительной информации, что минимизирует риск компрометации данных.
2. **Приватность**: Поддержание конфиденциальности данных, даже когда необходимо доказать знание или факт.

## Недостатки

1. **Сложность реализации**: Протоколы с нулевым разглашением могут быть сложными для реализации и требуют значительных вычислительных ресурсов.
2. **Выбор алгоритмов**: Не все криптографические задачи могут быть эффективно реализованы с использованием доказательств с нулевым разглашением.

---

# 7. Протоколы аутентификации и электронной подписи

Протоколы аутентификации и электронной подписи играют ключевую роль в обеспечении безопасности и доверия в цифровых коммуникациях. Они позволяют подтверждать подлинность пользователей и защищать целостность сообщений.

## Аутентификация

Аутентификация — это процесс проверки подлинности пользователя или устройства. Существует несколько методов аутентификации:

1. **Аутентификация по паролю**: Пользователь вводит секретный пароль, который проверяется на сервере.
2. **Многофакторная аутентификация (MFA)**: Включает использование нескольких факторов для аутентификации, таких как что-то, что знает пользователь (пароль), что-то, что у него есть (смартфон), и что-то, чем он является (отпечаток пальца).
3. **Сертификаты и PKI**: Используются цифровые сертификаты, выданные доверенными центрами сертификации (CA), для подтверждения подлинности пользователя.

## Примеры протоколов аутентификации

1. **Kerberos**: Сетевой протокол, который использует секретные ключи для аутентификации клиентов и серверов в незащищенной сети.
2. **OAuth**: Протокол аутентификации, который позволяет сторонним приложениям получать ограниченный доступ к ресурсам пользователя без передачи пароля.
3. **SAML (Security Assertion Markup Language)**: Протокол для обмена аутентификационной и авторизационной информацией между различными организациями.

## Электронная подпись

Электронная подпись — это цифровой эквивалент рукописной подписи, используемый для проверки подлинности и целостности цифровых сообщений и документов.

### Основные характеристики

1. **Аутентичность**: Подтверждает, что документ подписан именно тем лицом, которое заявлено как подписавшее.
2. **Целостность**: Гарантирует, что документ не был изменен после подписания.
3. **Неотказуемость**: Подписавший не может отрицать факт подписания документа.

## Примеры алгоритмов электронной подписи

1. **DSA (Digital Signature Algorithm)**: Использует математические свойства дискретных логарифмов для создания цифровой подписи.
2. **RSA (Rivest-Shamir-Adleman)**: Алгоритм, основанный на сложности факторизации больших чисел, который может использоваться как для шифрования, так и для создания цифровых подписей.
3. **ECDSA (Elliptic Curve Digital Signature Algorithm)**: Вариант DSA, использующий эллиптические кривые для обеспечения безопасности при меньшей длине ключа.

## Примеры протоколов с использованием электронной подписи

1. **SSL/TLS**: Использует цифровые сертификаты для аутентификации серверов и клиентов в интернете, обеспечивая безопасное соединение.
2. **PGP (Pretty Good Privacy)**: Протокол для шифрования и подписи электронной почты и файлов, который использует комбинацию симметричного и асимметричного шифрования.

---

# 8. Неотслеживаемость. Электронная монета

Неотслеживаемость и электронные монеты являются важными концепциями в области цифровой приватности и безопасности. Эти технологии позволяют осуществлять транзакции, не раскрывая личности участников и обеспечивая анонимность.

## Неотслеживаемость

Неотслеживаемость (Untraceability) — это свойство системы, которое обеспечивает невозможность отслеживания транзакций и действий пользователя, делая их анонимными и защищенными от внешнего наблюдения.

### Примеры технологий неотслеживаемости

1. **Микшеры (Mixers)**: Сервисы, которые перемешивают криптовалютные транзакции множества пользователей, затрудняя отслеживание исходных адресов.
2. **Анонимные сети**: Сети, такие как Tor, обеспечивают анонимность пользователей, скрывая их IP-адреса и маршруты передачи данных.
3. **Кольцевые подписи**: Метод, который позволяет группе пользователей подписывать сообщение без раскрытия личности конкретного подписавшего. Используется в криптовалютах, таких как Monero.

## Электронная монета

Электронная монета (E-cash) — это цифровая форма валюты, которая позволяет осуществлять электронные платежи и транзакции. Электронные монеты обеспечивают анонимность и безопасность транзакций, делая их привлекательными для использования в интернете.

### Основные характеристики

1. **Анонимность**: Электронная монета может быть использована для проведения анонимных транзакций, скрывая личность участников.
2. **Децентрализация**: Большинство электронных монет, таких как биткойн, функционируют на основе децентрализованных систем, что исключает необходимость в центральном органе для управления транзакциями.
3. **Безопасность**: Использование криптографических методов для защиты транзакций и предотвращения подделки или двойного расходования.

### Примеры электронных монет

1. **Биткойн (Bitcoin)**: Первая и самая известная криптовалюта, использующая блокчейн для обеспечения безопасности и децентрализации транзакций.
2. **Monero**: Криптовалюта, ориентированная на обеспечение анонимности и неотслеживаемости транзакций с использованием кольцевых подписей и скрытых адресов.
3. **Zcash**: Криптовалюта, использующая zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) для обеспечения полной анонимности транзакций.

## Применение технологий неотслеживаемости и электронных монет

1. **Анонимные платежи**: Использование электронных монет для проведения анонимных платежей в интернете, защищая личные данные пользователей.
2. **Защита конфиденциальности**: Технологии неотслеживаемости используются для защиты конфиденциальности пользователей в различных онлайн-сервисах и платформах.
3. **Борьба с цензурой**: Анонимные транзакции и коммуникации позволяют пользователям обходить цензуру и контролировать доступ к информации.

---

# 9. Протокол привязки к биту

Протокол привязки к биту (Bit Commitment Protocol) — это криптографический протокол, который позволяет одной стороне (отправителю) выбрать значение и зафиксировать его (привязать), а другой стороне (получателю) позволяет проверить это значение позднее, при этом отправитель не может изменить значение после его привязки.

## Основные характеристики

1. **Скрытность (Hiding)**: После привязки значение остается скрытым от получателя до момента раскрытия.
2. **Связывание (Binding)**: Отправитель не может изменить значение после привязки.

## Этапы протокола

1. **Этап привязки**: Отправитель выбирает значение и создает его привязку, отправляя зашифрованное значение получателю.
2. **Этап раскрытия**: Отправитель раскрывает значение и метод его привязки, что позволяет получателю проверить, что отправитель не изменил значение.

## Примеры использования протокола привязки к биту

1. **Криптографические протоколы**: Протокол привязки к биту используется в различных криптографических протоколах, таких как протоколы аукционов и электронного голосования.
2. **Схемы доказательства с нулевым разглашением**: Привязка к биту может использоваться для создания доказательств с нулевым разглашением, где одна сторона должна убедить другую в знании значения без его раскрытия.

## Пример реализации

Простая реализация протокола привязки к биту может быть основана на криптографической хеш-функции:

1. **Этап привязки**:
   - Отправитель выбирает случайное значение *r* и значение *b* (бит).
   - Отправитель вычисляет хеш *H(b || r)*, где || означает конкатенацию.
   - Отправитель отправляет получателю значение *H(b || r)*.

2. **Этап раскрытия**:
   - Отправитель отправляет получателю значения *b* и *r*.
   - Получатель вычисляет хеш *H(b || r)* и сравнивает его с полученным ранее значением.

### Пример

- Отправитель выбирает *b = 1* и *r = 1234*.
- Вычисляется хеш *H(1 || 1234)* и отправляется получателю.
- На этапе раскрытия отправитель сообщает *b = 1* и *r = 1234*.
- Получатель вычисляет *H(1 || 1234)* и проверяет, что оно совпадает с полученным ранее значением.

## Применение

1. **Электронное голосование**: Протоколы привязки к биту могут использоваться для обеспечения честности и конфиденциальности в системах электронного голосования.
2. **Обмен доказательствами**: Используется в схемах, где необходимо предоставить доказательство без раскрытия самого значения до определенного момента.

---

# 10. Протоколы электронного голосования

Протоколы электронного голосования предназначены для обеспечения безопасного, анонимного и проверяемого процесса голосования с использованием электронных средств. Эти протоколы должны удовлетворять требованиям конфиденциальности, целостности и аутентификации, чтобы гарантировать честность выборов.

## Основные требования к электронному голосованию

1. **Конфиденциальность (Anonymity)**: Голоса избирателей должны оставаться анонимными, чтобы предотвратить возможность их отслеживания.
2. **Целостность (Integrity)**: Голоса не должны быть изменены или удалены после их подачи.
3. **Аутентификация (Authentication)**: Только зарегистрированные избиратели могут участвовать в голосовании.
4. **Проверяемость (Verifiability)**: Избиратели должны иметь возможность проверить, что их голоса были учтены правильно.
5. **Справедливость (Fairness)**: Невозможно узнать промежуточные результаты голосования до его завершения.

## Примеры протоколов электронного голосования

1. **Протоколы на основе шифрования с гомоморфизмом**:
   - Гомоморфные шифры позволяют выполнять арифметические операции над зашифрованными данными без их расшифровки. Это обеспечивает конфиденциальность голосов, пока они не будут подсчитаны.
   - Пример: Использование схемы шифрования Паиллера (Paillier Encryption) для суммирования зашифрованных голосов.

2. **Протоколы на основе нулевого разглашения (Zero-Knowledge Proofs)**:
   - Использование доказательств с нулевым разглашением для подтверждения правильности голосования без раскрытия самих голосов.
   - Пример: Протоколы на основе zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge).

3. **Протоколы на основе микс-сетей (Mix-Nets)**:
   - Голоса проходят через серию серверов (миксеров), которые перемешивают их, обеспечивая анонимность и затрудняя отслеживание исходного голосования.
   - Пример: Протоколы Чаума (Chaum's Protocols) для анонимного голосования.

## Пример реализации

### Протокол голосования на основе гомоморфного шифрования

1. **Регистрация**:
   - Избиратели получают уникальные ключи для шифрования своих голосов.
   - Центральный орган генерирует ключи шифрования и рассылки.

2. **Голосование**:
   - Избиратель шифрует свой голос с использованием гомоморфного шифра.
   - Шифрованный голос отправляется на сервер голосования.

3. **Подсчет голосов**:
   - Сервер голосования выполняет операции над зашифрованными голосами, суммируя их.
   - После завершения голосования зашифрованные результаты расшифровываются центральным органом для получения итогов голосования.

4. **Проверка**:
   - Избиратели могут проверить, что их голоса были учтены, используя уникальные ключи или токены.

## Применение

1. **Национальные выборы**: Использование электронного голосования на выборах в национальные парламенты и президента.
2. **Корпоративные выборы**: Голосование акционеров в компаниях или выборы в корпоративные органы управления.
3. **Онлайн-опросы и референдумы**: Использование протоколов электронного голосования для проведения опросов и референдумов среди большого числа участников.

---

# 11. Порождение простых чисел и проверка чисел на простоту. Сложность теоретико-числовых алгоритмов

Простые числа играют ключевую роль в криптографии, особенно в алгоритмах шифрования с открытым ключом, таких как RSA. Порождение простых чисел и проверка чисел на простоту являются важными задачами в теории чисел.

## Порождение простых чисел

### Методы порождения простых чисел

1. **Решето Эратосфена**:
   - Эффективный алгоритм для нахождения всех простых чисел до заданного предела *n*.
   - Алгоритм последовательно исключает составные числа, оставляя только простые.

2. **Вероятностные методы**:
   - Используются для порождения больших простых чисел, необходимых в криптографии.
   - Пример: метод Миллера-Рабина.

### Пример метода Миллера-Рабина

1. Выберите случайное нечётное число *n*.
2. Проведите тест Миллера-Рабина для проверки, является ли *n* вероятно простым.
3. Если число прошло несколько раундов теста, оно считается простым с высокой вероятностью.

## Проверка чисел на простоту

### Детерминированные алгоритмы

1. **Алгоритм пробного деления**:
   - Проверяет, делится ли число на какое-либо из простых чисел до его квадратного корня.
   - Эффективен для небольших чисел, но не подходит для больших чисел из-за высокой вычислительной сложности.

2. **Алгоритм AKS**:
   - Первый детерминированный полиномиальный алгоритм проверки простоты.
   - Проверяет, удовлетворяет ли число определенному многочленному условию.
   - Сложность: *O(log(n)^6)*, где *n* — число цифр проверяемого числа.

### Вероятностные алгоритмы

1. **Тест Ферма**:
   - Основан на малой теореме Ферма.
   - Простые числа проходят тест, но некоторые составные числа (псевдопростые) могут его проходить.

2. **Тест Миллера-Рабина**:
   - Вероятностный тест, который проверяет, является ли число свидетелем простоты или составности.
   - Высокая вероятность правильного определения простоты после нескольких раундов теста.

## Сложность теоретико-числовых алгоритмов

### Сложность порождения простых чисел

- Для порождения больших простых чисел обычно используются вероятностные алгоритмы из-за их эффективности.
- Сложность метода Миллера-Рабина: *O(k log(n)^3)*, где *k* — число раундов теста, *n* — число цифр проверяемого числа.

### Сложность проверки простоты

- Детерминированные алгоритмы, такие как AKS, имеют полиномиальную сложность, но на практике часто используются вероятностные алгоритмы из-за их большей эффективности.
- Вероятностные алгоритмы, такие как тест Миллера-Рабина, имеют сложность *O(k log(n)^3)* и обеспечивают высокую вероятность правильного результата.

## Применение в криптографии

1. **Генерация ключей RSA**: Порождение больших простых чисел для создания открытого и закрытого ключей.
2. **Протоколы обмена ключами**: Использование простых чисел в алгоритмах Диффи-Хеллмана и других протоколах обмена ключами.
3. **Электронные подписи**: Простые числа используются в алгоритмах, таких как DSA и ECDSA, для создания цифровых подписей.

---

# 12. Протоколы разделения секрета

Протоколы разделения секрета (Secret Sharing Schemes) — это криптографические методы, которые позволяют распределить секрет среди группы участников таким образом, что для восстановления секрета требуется объединение определенного минимального количества частей (долей). Эти протоколы обеспечивают защиту секрета, даже если часть участников окажется скомпрометированной.

## Основные характеристики

1. **Пороговая схема**: Секрет делится на *n* частей, и для его восстановления требуется минимум *k* частей (где *k ≤ n*). Это называется *(k, n)*-пороговой схемой.
2. **Безопасность**: Даже если менее чем *k* участников объединят свои части, они не смогут узнать секрет.
3. **Комбинаторика**: Используются математические методы для генерации частей и восстановления секрета.

## Примеры протоколов разделения секрета

### Схема Шамира

Один из наиболее известных протоколов разделения секрета, предложенный Адлеманом Шамиром, основывается на интерполяции многочленов.

1. **Генерация долей**:
   - Выбирается случайный многочлен степени *k-1*: *f(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + ... + a<sub>k-1</sub>x<sup>k-1</sup>*, где *a<sub>0</sub>* — секрет.
   - Вычисляются значения многочлена для *n* различных значений *x* (долей), которые раздаются участникам.

2. **Восстановление секрета**:
   - Для восстановления секрета требуется минимум *k* частей.
   - Используется интерполяция Лагранжа для восстановления многочлена и вычисления значения *a<sub>0</sub>*.

### Схема Блэкли

Еще один известный протокол разделения секрета, предложенный Джорджем Блэкли.

1. **Генерация долей**:
   - Выбирается случайный вектор *V* длины *k* и *n* различных векторов *V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>n</sub>*.
   - Каждый участник получает часть секрета, состоящую из одного из векторов *V<sub>i</sub>*.

2. **Восстановление секрета**:
   - Для восстановления секрета требуется минимум *k* участников.
   - Используется линейная алгебра для восстановления оригинального вектора *V*.

## Применение протоколов разделения секрета

1. **Безопасное хранение данных**: Используется для защиты критически важных данных, распределяя их между несколькими участниками или серверами.
2. **Криптографические ключи**: Разделение ключа на части и распределение между участниками для повышения безопасности.
3. **Аутентификация и контроль доступа**: Используется в системах, где доступ к ресурсу предоставляется только при объединении нескольких участников.

## Преимущества

1. **Повышенная безопасность**: Секрет защищен от компрометации, пока не будет собрано минимально необходимое количество частей.
2. **Гибкость**: Возможность настройки параметров *(k, n)* для достижения нужного уровня безопасности и доступности.

## Недостатки

1. **Сложность управления**: Необходимо безопасно хранить и передавать доли секрета.
2. **Требования к синхронизации**: Для восстановления секрета требуется объединение нескольких участников.

---

# 13. Криптография на эллиптических кривых

Криптография на эллиптических кривых (Elliptic Curve Cryptography, ECC) — это подход к публично-ключевой криптографии, основанный на математических свойствах эллиптических кривых. ECC обеспечивает высокий уровень безопасности при меньшей длине ключа по сравнению с традиционными алгоритмами, такими как RSA.

## Основные понятия

### Эллиптическая кривая

Эллиптическая кривая определяется уравнением вида:
*y<sup>2</sup> = x<sup>3</sup> + ax + b*
где *a* и *b* — коэффициенты, которые задают конкретную кривую.

### Точки на эллиптической кривой

Точки на эллиптической кривой — это наборы координат *(x, y)*, которые удовлетворяют уравнению кривой. Операции на этих точках (например, сложение) определены особым образом и используются в криптографических алгоритмах.

## Преимущества ECC

1. **Высокая безопасность при меньшей длине ключа**: ECC обеспечивает эквивалентный уровень безопасности при значительно меньшей длине ключа по сравнению с RSA. Например, 256-битный ключ ECC соответствует по безопасности 3072-битному ключу RSA.
2. **Более эффективные вычисления**: Меньшая длина ключа приводит к более быстрым вычислениям и меньшему потреблению ресурсов.

## Применение ECC

1. **Шифрование**: Используется для шифрования данных с помощью схемы ЭлГамаля на эллиптических кривых.
2. **Цифровые подписи**: Алгоритм цифровой подписи на эллиптических кривых (ECDSA) используется для создания и проверки цифровых подписей.
3. **Обмен ключами**: Протокол Диффи-Хеллмана на эллиптических кривых (ECDH) позволяет двум сторонам безопасно обмениваться криптографическими ключами.

## Примеры алгоритмов

### ECDSA (Elliptic Curve Digital Signature Algorithm)

Алгоритм цифровой подписи, обеспечивающий аутентификацию и целостность сообщений.

1. **Генерация ключей**:
   - Выбирается случайное приватное значение *d*.
   - Вычисляется соответствующее публичное значение *Q = dG*, где *G* — генератор на эллиптической кривой.

2. **Подпись**:
   - Для сообщения *m* вычисляется хеш *e = H(m)*.
   - Выбирается случайное значение *k* и вычисляется точка *R = kG*.
   - Вычисляются значения *r = R<sub>x</sub>* и *s = k<sup>-1</sup>(e + dr) mod n*.
   - Пара *(r, s)* является цифровой подписью сообщения *m*.

3. **Проверка подписи**:
   - Проверяется, что *r* и *s* находятся в допустимых пределах.
   - Вычисляется хеш *e = H(m)*.
   - Вычисляются точки *u1 = e * s<sup>-1</sup> mod n* и *u2 = r * s<sup>-1</sup> mod n*.
   - Вычисляется точка *P = u1G + u2Q*.
   - Подпись считается действительной, если *P<sub>x</sub> ≡ r (mod n)*.

### ECDH (Elliptic Curve Diffie-Hellman)

Протокол обмена ключами, который позволяет двум сторонам безопасно обмениваться симметрическим ключом.

1. **Генерация ключей**:
   - Каждая сторона генерирует свою пару ключей *(d, Q = dG)*.

2. **Обмен ключами**:
   - Каждая сторона передает свой публичный ключ другой стороне.

3. **Вычисление общего секрета**:
   - Каждая сторона вычисляет общий секрет как *S = d * Q'*, где *Q'* — публичный ключ другой стороны.

## Применение

1. **SSL/TLS**: ECC используется для установления безопасных соединений в интернете.
2. **Криптовалюты**: Многие криптовалюты, включая биткойн и эфириум, используют ECDSA для подписей транзакций.
3. **Смарт-карты и устройства IoT**: ECC используется в устройствах с ограниченными ресурсами благодаря своей эффективности.

---


